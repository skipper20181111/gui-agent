# GUI Agent 技术方案选型文档

## 1. 总体架构方案对比

### 1.1 方案概述

| 方案 | 描述 | 优点 | 缺点 |
|------|------|------|------|
| **DOM 方案** | 解析页面 DOM 树，提取元素信息供模型决策 | Token 消耗低，定位精准 | 兼容性差，适用场景有限 |
| **纯视觉方案** | 仅依赖屏幕截图，模型理解图像内容并输出坐标 | 通用性强，无需适配 | Token 消耗高，依赖模型视觉能力 |
| **混合方案** | Agent 自主选择 DOM 或视觉方式 | 理论最优 | 实现复杂，且 DOM 工具适用场景有限 |

### 1.2 DOM 方案的优势

#### 1.2.1 效率优势

| 场景 | DOM 方案 | 纯视觉方案 |
|------|---------|-----------|
| **信息获取** | 一次获取页面所有可操作元素 | 需多次滚动截图才能看全 |
| **滚动操作** | 可直接跳转到目标元素 | 需反复滚动、截图、判断 |
| **决策速度** | 结构化数据，模型快速理解 | 图片解析，Token 消耗高 |

#### 1.2.2 实际案例：医院挂号场景

以挂号为例，页面包含多个科室分类和大量可预约专科：

| 方案 | 操作流程 | 耗时 |
|------|---------|------|
| **DOM 方案** | 一次性获取所有科室列表 → 模型直接选择目标科室 → 点击挂号 | 1-2 轮 |
| **纯视觉方案** | 截图 → 看不到目标科室 → 滚动 → 截图 → 继续滚动... → 找到 → 点击 | 5-10 轮 |

**DOM 方案可将所有可预约专科直接给到模型**，模型可快速决策，无需反复滚动查找。

### 1.3 DOM 方案的局限性

尽管 DOM 方案在效率上有优势，但存在以下**核心缺陷**：

#### 1.3.1 技术层面

| 问题 | 具体表现 |
|------|---------|
| **Canvas 无法解析** | 游戏、图表、白板等 Canvas 应用无 DOM 结构 |
| **代码混淆** | 现代前端框架（React/Vue）打包后 class/id 无语义 |
| **Shadow DOM** | Web Components 内部 DOM 无法直接访问 |
| **iframe 跨域** | 跨域 iframe 内部 DOM 无法获取 |

#### 1.3.2 平台层面

| 平台 | DOM 支持情况 |
|------|-------------|
| **移动端原生 App** | 完全无 DOM，需依赖 Accessibility API |
| **微信小程序** | 自定义组件结构，与 Web DOM 不兼容 |
| **桌面应用** | Electron 有 DOM，原生应用无 DOM |
| **跨平台框架** | Flutter/React Native 无标准 DOM |

#### 1.3.3 获取成本

| 问题 | 说明 |
|------|------|
| **需要浏览器插件/控制** | 必须通过 Chrome Extension 或 Playwright 等工具获取 DOM |
| **无法适配任意应用** | 只能针对特定平台开发，通用性差 |
| **Demo 验证困难** | 快速验证想法时，DOM 方案的前置工作量大 |

### 1.4 选型结论

#### 1.4.1 生产环境推荐：混合方案

| 条件 | 推荐方案 |
|------|---------|
| **能获取 DOM** | 优先使用 DOM，效率高、Token 消耗低 |
| **无法获取 DOM** | 降级到纯视觉方案 |

混合方案可兼顾效率与兼容性，Agent 根据当前环境自动选择最优策略。

#### 1.4.2 当前选择：纯视觉方案

**选择原因**：
- ✅ **Demo 验证优先**：快速验证 GUI Agent 的可行性，无需开发 DOM 获取工具
- ✅ **通用性强**：跨平台通用（Web/Desktop/Mobile），无需适配不同技术栈
- ✅ **实现简单**：无需浏览器插件或额外依赖

**权衡**：
- ❌ 效率较低：需多次滚动截图
- ❌ Token 消耗高：每张截图约 1000-2000 tokens

> **注**：当前选择纯视觉方案是因为 Demo 阶段无法获取 DOM。在生产环境中，若能获取 DOM，建议采用混合方案以提升效率。

### 1.5 最终选择：纯视觉方案（Demo 阶段）

**核心优势**：
- ✅ 跨平台通用（Web/Desktop/Mobile）
- ✅ 无需适配不同技术栈
- ✅ 对混淆/Canvas/原生应用均有效
- ✅ 与人类操作方式一致

---

## 2. 模型选型

### 2.1 候选模型评估

| 模型 | Tool Call 能力 | 视觉理解 | 坐标定位 | 逻辑推理 | 结论 |
|------|---------------|---------|---------|---------|------|
| **豆包 1.5 UI-TARS** | ❌ 极差 | ✅ 正常 | ✅ 正常 | ❌ 较差 | 不可用 |
| **豆包 1.6 Pro Vision** | ✅ 正常 | ✅ 正常 | ✅ 正常 | ❌ 较差 | 不推荐 |
| **Gemini 3 Flash** | ✅ 优秀 | ✅ 优秀 | ✅ 优秀 | ✅ 优秀 | **最终选择** |

### 2.2 问题详情

#### 豆包 1.5 UI-TARS

**问题 1**：Tool Call 输出极不稳定
- 将本应在 `tool_calls` 字段中的 JSON 直接输出到 `content` 文本中
- 无法被 Agent 框架正确解析为工具调用
- 无法作为 Agent 的执行引擎

**问题 2**：逻辑推理能力差
- 遇到操作失败时无法分析原因
- 不会根据反馈调整策略
- 容易陷入重复错误操作的死循环

#### 豆包 1.6 Pro Vision

**问题**：逻辑推理能力不足，缺乏变通

| 场景 | 预期行为 | 实际行为 |
|------|---------|---------|
| 输入换行 | 使用 `type_text("line1\nline2")` 或 `Enter` 键 | 反复尝试 `type_text` 失败 |
| 按钮被遮挡 | 先滚动/关闭弹窗 | 直接点击失败位置 |
| 输入框未聚焦 | 先点击输入框 | 直接输入无效 |

- 不理解 `\n` 与回车键的区别
- 遇到障碍时不会变通，反复重试同一失败操作
- 逻辑推理能力不足，无法分析失败原因

> **注**：豆包 1.6 的 Tool Call、视觉理解、坐标定位能力均正常，**唯一短板是逻辑推理**。

### 2.3 最终选择：Gemini 3 Flash

| 能力 | 表现 |
|------|------|
| **Tool Call** | 100% 正确输出结构化调用 |
| **视觉理解** | 准确识别 UI 元素、文字、图标 |
| **坐标定位** | 坐标误差小，点击准确 |
| **逻辑推理** | 能分析操作失败原因并调整策略 |
| **指令遵循** | 严格按照 System Prompt 执行 |

---

## 3. Agent 框架选型

### 3.1 候选框架评估

| 框架 | 特点 | 问题 | 结论 |
|------|------|------|------|
| **Google ADK** | 针对 Gemini 优化 | 不支持 OpenAI 格式的图片作为 Tool Call 返回 | 放弃 |
| **AgentScope** | 阿里出品，功能完善 | Gemini 模型供应商兼容性未做好 | 放弃 |
| **自己实现 ReAct** | 完全可控，实现简单 | 需自行实现 | **最终选择** |

### 3.2 问题详情

#### Google ADK

**问题**：Tool Call 返回图片的兼容性
- ADK 内部转换逻辑不支持 OpenAI 格式的 Tool Call `image_url` 返回
- 使用第三方 API 代理时无法正常工作

#### AgentScope

**问题**：Gemini 模型供应商兼容性不完整
- 第三方 Gemini API 供应商未适配 Tool Call 的图片返回
- 图片数据在传输过程中丢失

### 3.3 最终选择：自己实现 ReAct Agent

**设计思路**：

由于主流框架都存在图片返回兼容性问题，选择自己实现 ReAct Agent（ReAct 逻辑本身非常简单），**绕过 Tool Call 返回图片的限制**：
- 传统方式：Tool 结果（含图片）作为 `tool` message → 供应商不支持
- 我们的方式：Tool 结果仅返回文本，图片作为 `user` message 追加 → 全兼容

**优点**：
- ✅ 兼容所有 OpenAI 格式 API
- ✅ 无需依赖供应商的图片返回支持
- ✅ ReAct 循环逻辑简单，易于调试
- ✅ 完全可控，可灵活扩展

---

## 4. Token 优化策略

### 4.1 问题背景

纯视觉方案的最大问题是 **Token 消耗爆炸**：
- 每张截图 ≈ 1000-2000 tokens
- 10 轮迭代 ≈ 10 张截图
- 单次任务 ≈ 10,000-20,000 tokens（仅图片）

### 4.2 解决方案：截图历史裁剪

**策略**：只保留最近 N 张截图，更早的截图从上下文中移除，但保留文本描述。

### 4.3 效果对比

| 场景 | 无裁剪 | 保留 5 张 | 节省 |
|------|-------|----------|------|
| 5 轮迭代 | 5 张 | 5 张 | 0% |
| 10 轮迭代 | 10 张 | 5 张 | 50% |
| 20 轮迭代 | 20 张 | 5 张 | 75% |

**权衡**：
- 截图数量过少：模型可能丢失上下文，重复错误操作
- 截图数量过多：Token 消耗高，响应变慢
- **经验值**：5 张截图是较好的平衡点

---

## 5. 工具集设计

### 5.1 当前工具列表

| 工具 | 功能 |
|------|------|
| screenshot | 截取当前屏幕 |
| click | 点击指定坐标 |
| double_click | 双击指定坐标 |
| right_click | 右键点击指定坐标 |
| type_text | 在当前焦点位置输入文本（支持中文） |
| scroll | 滚动屏幕 |

### 5.2 坐标系统

**设计决策**：使用 **0-1000 归一化坐标**

**优点**：
- 模型输出稳定（整数范围 0-1000）
- 屏幕分辨率无关
- 避免 Retina 缩放问题

### 5.3 截图时机

| 工具 | 截图延迟 | 原因 |
|------|---------|------|
| screenshot | 0ms | 立即获取当前状态 |
| click/double_click/right_click | 500ms | 等待界面响应 |
| type_text | 500ms | 等待文字渲染 |
| scroll | 500ms | 等待滚动动画 |

**优化方向**：当前采用固定延迟，未来可改为检测页面变化或超时后再截图，减少不必要的等待时间。

---

## 6. 总结

### 6.1 技术栈

| 层次 | 选型 | 原因 |
|------|------|------|
| **架构方案** | 纯视觉方案 | 跨平台通用，无需适配 |
| **视觉模型** | Gemini 3 Flash | Tool Call 稳定，视觉理解强 |
| **Agent 框架** | 自己实现 ReAct | 绕过图片返回兼容性问题，实现简单 |
| **GUI 操作** | PyAutoGUI | 跨平台，API 简洁 |

### 6.2 关键设计

1. **图片作为 User Message**：绕过 Tool Call 图片返回的兼容性问题
2. **截图历史裁剪**：控制 Token 消耗，保留最近 5 张截图
3. **归一化坐标**：0-1000 范围，屏幕分辨率无关
4. **精简工具集**：6 个核心工具，覆盖 90% 使用场景

### 6.3 未来优化方向

| 方向 | 描述 |
|------|------|
| **智能截图时机** | 检测页面变化或超时后再截图，替代固定延迟 |
